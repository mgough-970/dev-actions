name: Full Notebook CI Pipeline

on:
  workflow_call:
    inputs:
      python-version:
        required: true
        type: string
      execution-mode:
        required: true
        type: string
      single-filename:
        required: false
        type: string
      build-html:
        required: false
        type: boolean
        default: true
      security-scan:
        required: false
        type: boolean
        default: true
      use-conda:
        required: false
        type: boolean
        default: false
      conda-environment-file:
        required: false
        type: string
      conda-packages:
        required: false
        type: string
    secrets:
      CASJOBS_USERID:
        required: false
      CASJOBS_PW:
        required: false

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      notebooks_json: ${{ steps.set.outputs.notebooks_json }}
      dependencies_changed: ${{ steps.set.outputs.dependencies_changed }}
      static_changed: ${{ steps.set.outputs.static_changed }}
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - id: set
      run: |
        git fetch origin main

        echo "Detecting changes..."

        NOTEBOOKS_TO_RUN=()

        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "Manual run detected."

          if [[ "${{ inputs.execution-mode }}" == "all" ]]; then
            echo "Finding all notebooks..."
            NOTEBOOKS_TO_RUN=($(find notebooks/ -name '*.ipynb'))

          elif [[ "${{ inputs.execution-mode }}" == "single" ]]; then
            echo "Looking for single notebook: ${{ inputs.single-filename }}"
            NOTEBOOK_PATH=$(find notebooks/ -name "${{ inputs.single-filename }}" | head -n 1)
            if [[ -z "$NOTEBOOK_PATH" ]]; then
              echo "ERROR: Single notebook '${{ inputs.single-filename }}' not found."
              exit 1
            fi
            NOTEBOOKS_TO_RUN=("$NOTEBOOK_PATH")

          else
            echo "Invalid manual execution mode: ${{ inputs.execution-mode }}"
            exit 1
          fi

        else
          echo "PR or Push event detected."

          # 1. Check if global requirements files changed
          GLOBAL_DEPS=$(git diff --name-only origin/main HEAD -- requirements.txt environment.yml pre-requirements.sh)
          if [[ -n "$GLOBAL_DEPS" ]]; then
            echo "Global dependency file change detected."
            NOTEBOOKS_TO_RUN+=($(find notebooks/ -name '*.ipynb'))
          fi

          # 2. Check if subfolder requirements.txt files changed
          SUBFOLDER_DEPS=$(git diff --name-only origin/main HEAD -- 'notebooks/**/requirements.txt')
          for file in $SUBFOLDER_DEPS; do
            if [[ -n "$file" ]]; then
              folder=$(dirname "$file")
              echo "Subfolder requirements.txt change detected in $folder"
              NOTEBOOKS_TO_RUN+=($(find "$folder" -name '*.ipynb'))
            fi
          done

          # 3. Check if notebooks themselves changed
          CHANGED_NOTEBOOKS=$(git diff --name-only origin/main HEAD -- 'notebooks/**/*.ipynb')
          for nb in $CHANGED_NOTEBOOKS; do
            if [[ -n "$nb" ]]; then
              NOTEBOOKS_TO_RUN+=("$nb")
            fi
          done
        fi

        # De-duplicate
        NOTEBOOKS_TO_RUN=($(printf "%s\n" "${NOTEBOOKS_TO_RUN[@]}" | sort -u))

        # Output final list
        if [[ ${#NOTEBOOKS_TO_RUN[@]} -eq 0 ]]; then
          echo "No notebooks detected for validation."
          echo "notebooks_json=[]" >> $GITHUB_OUTPUT
        else
          NOTEBOOKS_JSON=$(printf '%s\n' "${NOTEBOOKS_TO_RUN[@]}" | jq -R . | jq -s .)
          echo "Detected notebooks for validation:"
          echo "$NOTEBOOKS_JSON"
          echo "notebooks_json<<EOF" >> $GITHUB_OUTPUT
          echo "$NOTEBOOKS_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        fi

        # Output dependency and static flags
        DEPS_CHANGED=$(git diff --name-only origin/main HEAD -- requirements.txt environment.yml pre-requirements.sh | tr '\n' ' ')
        echo "dependencies_changed=$([[ -n \"$DEPS_CHANGED\" ]] && echo true || echo false)" >> $GITHUB_OUTPUT

        STATIC_CHANGED=$(git diff --name-only origin/main HEAD -- '*.md' static/** assets/** | tr '\n' ' ')
        echo "static_changed=$([[ -n \"$STATIC_CHANGED\" ]] && echo true || echo false)" >> $GITHUB_OUTPUT


  
  validate-and-execute:
    needs: detect-changes
    runs-on: ubuntu-latest
    if: ${{ needs.detect-changes.outputs.notebooks_json != '[]' }}
    strategy:
      matrix:
        notebook: ${{ fromJson(needs.detect-changes.outputs.notebooks_json) }}
      fail-fast: false
      max-parallel: 4
  
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
  
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python-version }}
  
      - name: Set up Conda Environment
        if: inputs.use-conda == true
        shell: bash -l {0}
        run: |
          echo "ðŸ”§ Creating Conda environment..."
          source /usr/share/miniconda/etc/profile.d/conda.sh
          conda create --yes --solver=classic -n ci_env -c conda-forge python=${{ inputs.python-version }}
  
          if [[ -n "${{ inputs.conda-environment-file }}" ]]; then
            echo "ðŸ“¦ Installing from Conda environment file"
            conda env update -n ci_env -f "${{ inputs.conda-environment-file }}"
          elif [[ -n "${{ inputs.conda-packages }}" ]]; then
            echo "ðŸ“¦ Installing Conda packages: ${{ inputs.conda-packages }}"
            conda install -n ci_env -c conda-forge $(echo "${{ inputs.conda-packages }}" | tr ',' ' ') -y
          fi
  
      - name: Install Base CI Tools + Kernel Registration
        shell: bash -l {0}
        run: |
          source /usr/share/miniconda/etc/profile.d/conda.sh
          conda activate ci_env
  
          echo "ðŸ“¦ Installing base CI packages (jupyter, nbval, nbconvert, bandit, ipykernel)..."
          pip install jupyter nbval nbconvert bandit ipykernel
  
          echo "ðŸ§  Registering Jupyter kernel for ci_env"
          python -m ipykernel install --user --name=ci_env --display-name "Python (ci_env)"
  
      - name: Install Local Requirements (optional pip-only)
        shell: bash -l {0}
        run: |
          NOTEBOOK="${{ matrix.notebook }}"
          REQFILE="$(dirname "$NOTEBOOK")/requirements.txt"
  
          source /usr/share/miniconda/etc/profile.d/conda.sh
          conda activate ci_env
  
          if [ -f "$REQFILE" ]; then
            echo "ðŸ“¦ Installing requirements: $REQFILE"
            pip install -r "$REQFILE"
          else
            echo "â„¹ï¸ No local requirements.txt found â€” skipping"
          fi
  
      - name: Validate Notebook
        shell: bash -l {0}
        run: |
          NOTEBOOK="${{ matrix.notebook }}"
  
          source /usr/share/miniconda/etc/profile.d/conda.sh
          conda activate ci_env
  
          echo "ðŸ§ª Python: $(which python)"
          python -c "import numpy; print('âœ… numpy version:', numpy.__version__)"
  
          echo "âœ… Validating notebook: $NOTEBOOK"
          jupyter nbconvert --clear-output --inplace "$NOTEBOOK"
          pytest --nbval --nbval-cell-timeout=4000 "$NOTEBOOK"
  
      - name: Execute Notebook
        shell: bash -l {0}
        run: |
          NOTEBOOK="${{ matrix.notebook }}"
  
          source /usr/share/miniconda/etc/profile.d/conda.sh
          conda activate ci_env
  
          echo "ðŸš€ Executing notebook: $NOTEBOOK"
          if ! jupyter nbconvert --to notebook --execute --inplace "$NOTEBOOK" --ExecutePreprocessor.kernel_name=ci_env; then
            echo "âš ï¸ Execution failed â€” inserting failure marker"
            python .github/scripts/insert_failure_message.py "$NOTEBOOK"
          fi
  
      - name: Security Scan Notebook
        if: inputs.security-scan == true
        shell: bash -l {0}
        run: |
          NOTEBOOK="${{ matrix.notebook }}"
          PYFILE="${NOTEBOOK%.ipynb}.py"
  
          source /usr/share/miniconda/etc/profile.d/conda.sh
          conda activate ci_env
  
          echo "ðŸ” Converting to .py for Bandit scan: $PYFILE"
          jupyter nbconvert --to script "$NOTEBOOK"
          bandit "$PYFILE"
  
      - name: Upload Notebook if Failure
        if: failure()
        shell: bash
        run: |
          NOTEBOOK="${{ matrix.notebook }}"
          SAFE_NAME=$(echo "$NOTEBOOK" | sed 's#/#__#g')
  
          echo "ðŸ’¾ Archiving failed notebook: $SAFE_NAME"
          mkdir -p failed_notebooks
          cp "$NOTEBOOK" "failed_notebooks/${SAFE_NAME}"
          tar -czf "failed-${SAFE_NAME}.tar.gz" -C failed_notebooks .
  
      - name: Upload Failed Notebook Artifact
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: failed-${{ matrix.notebook }}
          path: ${{ matrix.notebook }}



  post-merge-storage-update:
    needs: [detect-changes, validate-and-execute]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v4
      with:
        ref: gh-storage
        fetch-depth: 0

    - name: Checkout Main to temp dir
      run: |
        mkdir main-checkout
        cd main-checkout
        git init
        git remote add origin https://github.com/${{ github.repository }}
        git fetch origin main
        git checkout FETCH_HEAD

    - name: Find changed notebooks from main
      id: find-changes
      run: |
        cd main-checkout
        NOTEBOOKS=$(git diff --name-only origin/gh-storage FETCH_HEAD -- 'notebooks/**/*.ipynb' | tr '\n' ' ')
        echo "changed=$NOTEBOOKS" >> $GITHUB_OUTPUT

    - name: Re-execute and update gh-storage
      if: steps.find-changes.outputs.changed != ''
      run: |
        cd main-checkout
        for file in ${{ steps.find-changes.outputs.changed }}; do
          echo "Executing $file"
          jupyter nbconvert --to notebook --execute --inplace "$file"
          cp "$file" ../
        done

    - name: Commit updated notebooks
      if: steps.find-changes.outputs.changed != ''
      run: |
        git config --global user.name "CI Bot"
        git config --global user.email "ci-bot@example.com"
        git add ${{ steps.find-changes.outputs.changed }}
        git commit -m "Post-merge executed notebook updates"
        git push origin gh-storage
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-html-site:
    needs: [post-merge-storage-update]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    uses: mgough-970/dev-actions/.github/workflows/ci_html_builder.yml@v1
    secrets:
      github-token: ${{ secrets.GITHUB_TOKEN }}
